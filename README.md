## Приложение чат

В этом репозитории реализована первая часть тестового задания.

### Требования

Функционал:
- Пользователь может зарегистрироваться в системе.
- Пользователь может авторизоваться в системе.
- Авторизовавшийся пользователь может пользоваться чатом с другими пользователями системы. В  чате можно отправлять и принимать сообщения от собеседников.

Способ реализации:
- одно Ruby on Rails приложение

###  Реализация

Требований по версии ПО не было, поэтому я использовал последние стабильные версии Ruby и RoR.

Использованное ПО:
- Ruby 2.3.0
- Rails 4.2.5
- Devise
- Faye
- Docker
- Thin Webserver

Для регистрации и авторизации пользователей использована библиотека Devise.
Чат на вебсокетах с использованием [Faye](faye.jcoglan.com), веб сервер Thin для поддержки асинхронных вызовов. Для простоты, приложение можно запускать в Docker контейнере.

Из-за демонстрационного смысла приложения сделан ряд упрощений:
- приложенине запускается в development окружении в Docker контейнере
- опущены все validations у моделей
- используется стандарная база данных Sqlite3
- Ни строчки CSS :)

Также в [этом](https://github.com/gabyshev/chat_monolith/commit/13b150f1fbd73ba15f8494e80f141f1c7ae4a72b) коммите, я вставил разъясняющие комментарии на все важные, на мой взгляд, моменты в приложении.

### Логика

Для безопасности, все запросы с фронтенда вшивают в мета инфомацию вебсокет запроса base64 значение сгенерированного CSRF токена.
На сервере полученный токен декодируется и сравнивается со значением, которое хранится на сервере.

#### Backend

У пользователя может быть несколько чатов в другими пользователями.
Чат (conversation) может включать в себя только 2 участников. Все сообщения (message) хранятся в базе.
При создании нового сообщения происходит `publish` сообщения по вебсокетам на канал вида: `/conversation/CONVERSATION_ID`.

#### Frontend

При открытии страницы на список пользователей вешается событие на `click`.
При клике создается объект `Chat.Conversation`, происходит подписка на канал вида `/conversation/CONVERSATION_ID`, отрисовывается чат и подгружаются сообщения по этому чату.
Новое сообщение отправляется по ajax на сервер, там происходит `publish` нового сообщения и клиенты подписанные на этот канал его получат.
При открытии чата с другим пользователем текущая подписка удаляется и создается новая.

### Запуск

```
cd ../path/to/app
docker build --rm -t chat .
docker run -p 80:3000 -d chat
```
Если запуск происходит с OS X, приложение можно будет открыть по IP-адресу который хранится в ENV `$DOCKER_HOST` с портом 80.
Для Linux, приложение можно будет посмотреть по `localhost`

### Возможные улучшения

1. Хранение сообщений в реляционной базе довольно узкое место. Вот что было бы нужно сделать в настоящем production окружении:
 - кешировать сообщения в быстрой БД типа Redis
 - при больших нагрузках использовать отложенную запись данных
 - масштабировать сам Redis, используя, например, шардинг
 - не отдавать сразу все сообщения чата, а отдавать последние N и догружать порционно остальные по мере надобности отдельными запросами
2. Дизайн :)
